defmodule PhoenixPostgresPubSub do
  use GenServer
  import Poison

  @moduledoc """
  # PhoenixPostgresPubSub
  Listen to changes to the tables of your Postgres database. For every INSERT or UPDATE in a specified table, a function will be called with the payload.
  ## Installation
  If [available in Hex](https://hex.pm/docs/publish), the package can be installed
  by adding `phoenix_postgres_pub_sub` to your list of dependencies in `mix.exs`:
  ```elixir
  def deps do
    [
      {:phoenix_postgres_pub_sub, "~> 0.1.0"}
    ]
  end
  ```
  ## Configuration
  In your config.exs add the following:
  ```elixir
    config :phoenix_postgres_pub_sub, :config,
      adapter: MainModuleOfYourApp, # this should be the main module of your phoenix application
      repo: MainModuleOfYourApp.Repo # and this should be the main repo of your phoenix application
  ```
  In your Application Module change the configuration in the following way:
  ```elixir
    defmodule MainModuleOfYourApp do
    use Application
    # See http://elixir-lang.org/docs/stable/elixir/Application.html
    # for more information on OTP Applications
    def start(_type, _args) do
      import Supervisor.Spec, warn: false
      children = [
        # Start the endpoint when the application starts
        supervisor(MainModuleOfYourApp.Endpoint, []),
        # Start the Ecto repository
        worker(MainModuleOfYourApp.Repo, []),
        worker(
          PhoenixPostgresPubSub,
          [
            [
              "skills_changes" # this should be always in the format NAME_OF_TABLE_changes,
              "users_changes" # this should be always in the format NAME_OF_TABLE_changes,
              "companies_changes" # this should be always in the format NAME_OF_TABLE_changes,
              ...
            ]
          ],
          restart: :permanent
        ),
        # Here you could define other workers and supervisors as children
        # worker(MainModuleOfYourApp.Worker, [arg1, arg2, arg3]),
      ]
  ```
  ## Generate the migration
  At this point you have to generate a migration to add the trigger to Postgres.
  You can do this by running the following command:
  ```
  mix phoenix_postgres_pub_sub.gen.channel CHOOSE_A_MIGRATION_NAME --table=users
  # check the migration file just generated and make your changes if necessary
  ```
  And run the migration with `mix ecto.migration`
  `--table` is the table upon which your want to listen to changes
  ## Generate your adapter
  Create a module called something like `MainModuleOfYourApp.PhoenixPostgresPubSub`.
  This module should have a function called `handle_postgres_notification` that accepts two arguments: notification, state
  The notification is the one generated by Postgres and sent to this function, while the state is the state of GenServer of PhoenixPostgresPubSub
  ## Test it out
  You you have followed all the steps correctly you should be able to make changes to the table on which your are listening to and you should see that the function `MainModuleOfYourApp.PhoenixPostgresPubSub.handle_postgres_notification/2` is called every time this happens.
  """

  @doc """
  Initialize the GenServer
  """
  @spec start_link(List.t()) :: {:ok, pid}
  def start_link(channels), do: GenServer.start_link(__MODULE__, channels, name: __MODULE__)

  @doc """
  When the GenServer starts subscribe to the given channel
  """
  @spec init(List.t()) :: {:ok, []}
  def init(channels) do
    pg_config = repo().config()
    {:ok, pid} = Postgrex.Notifications.start_link(pg_config)

    list_of_channels = List.wrap(channels)
    Enum.map(list_of_channels, fn channel -> Postgrex.Notifications.listen(pid, channel) end)

    {:ok, {pid, channels, nil}}
  end

  @doc """
  Listen for changes
  """
  def handle_info(notification, state) do
    {_, _, _, _, data} = notification
    data = Poison.decode(data)

    apply(Scrumpointer.PhoenixPostgresPubSub, :handle_postgres_notification, [data, state])

    {:noreply, :event_handled}
  end

  defp repo() do
    Scrumpointer.Repo
  end
end
